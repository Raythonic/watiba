#!/usr/bin/python3.8
import os

# This will change the CWD for all subsequent commands
`cd /tmp`

# This will CWD only for the commands within the backticks,
# but NOT for any subsequent commands (the dash prefix prevents the context
# change)
-`cd /home`

# This demonstrates a CWD change that is only contained within the backticks
# This will print "/tmp" as the CWD not "/home"
print("CWD is not /home: {}".format(-`cd /home`.cwd))

# This will find text file in /tmp/, not /home
w = `find . -name '*.txt'`
for l in w.stdout:
    print("File: {}".format(l))


# This will print the output from the tar commands
print(`echo "BLAH!" > /tmp/blah.txt && tar -zcvf /tmp/blah.tar.gz /tmp/blah.txt`.stderr)

# This will print just the first line from the command's output
print(`cat file.txt`.stdout[0])

# Example of more than one command in a statement line
if len(`ls -lrt`.stdout) > 0 or len(-`cd /tmp`.stdout) > 0:
    print("You have stdout or stderr messages")


# Example of receiving a Watiba object and operating from that
# and demonstrating a command from a Python variable
cmd = "tar -zcvf /tmp/watiba_test.tar.gz /mnt/data/git/watiba/src"
results = `$cmd`
if results.exit_code == 0:
    for l in results.stderr:
        print(l)

# Print the files from the CWD, which is still /tmp from above (context)
#  Iterate on the stdout property
for l in `ls -lrt`.stdout:
    print(l)

# Example of printing the exit code of a failed commands
print("Return code: {}".format(`badcmd`.exit_code))


# Demonstrate context.  CWD is still /tmp
print(`pwd`.cwd)

# Running a command asynchonously with the outer code
# looking for the creation of a file to signal its completion
print("running async test")
`rm /tmp/done`
w_async(`ls -lrt`):
    # This is the resolver block
    print("Async command done!")
    print("results {}".format(results.stdout))
    `touch /tmp/done`

while not os.path.exists("/tmp/done"):
    `sleep 3`

print("test complete.")
